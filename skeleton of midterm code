import numpy as np
import matplotlib.pyplot as plt

# Set up initial conditions
G = 6.67430e-11  # Gravitational constant
m_A = 1e11  # Mass of galaxy A
m_B = 1e11  # Mass of galaxy B
R_min = 25  # Pericenter distance
e = 0.6  # Eccentricity
t_init = -16.4  # Initial time
t_final = 6.086  # Final time
dt = 0.01  # Time step

# Function to calculate gravitational force
def gravitational_force(m1, m2, r):
    return G * m1 * m2 / (r**2)

# Function to calculate acceleration
def acceleration(m1, m2, r, pos):
    force = gravitational_force(m1, m2, r)
    return force * pos / (m1 * r)

# Function to update positions and velocities using Leapfrog integration
def leapfrog_integration(pos, vel, acc, dt):
    pos += vel * dt + 0.5 * acc * dt**2
    vel += 0.5 * acc * dt
    return pos, vel

# Function to simulate the galaxy collision
def simulate_collision():
    t = t_init
    pos_A = np.array([0.7 * R_min, 0])  # Initial position of galaxy A
    vel_A = np.array([0, np.sqrt((1+e) * G * m_B / (0.7 * R_min))])  # Initial velocity of galaxy A
    pos_B = np.array([-0.7 * R_min, 0])  # Initial position of galaxy B
    vel_B = np.array([0, -np.sqrt((1+e) * G * m_A / (0.7 * R_min))])  # Initial velocity of galaxy B

    # Lists to store the positions of test particles
    test_particles_A = []
    test_particles_B = []

    while t <= t_final:
        # Update positions and velocities of galaxies
        r_A = np.linalg.norm(pos_A)
        r_B = np.linalg.norm(pos_B)
        acc_A = acceleration(m_A, m_B, r_A, pos_A)
        acc_B = acceleration(m_B, m_A, r_B, pos_B)
        pos_A, vel_A = leapfrog_integration(pos_A, vel_A, acc_A, dt)
        pos_B, vel_B = leapfrog_integration(pos_B, vel_B, acc_B, dt)

        # Append positions of test particles to the lists
        test_particles_A.append(pos_A.copy())
        test_particles_B.append(pos_B.copy())

        t += dt

    return test_particles_A, test_particles_B

# Run the simulation
test_particles_A, test_particles_B = simulate_collision()

# Plot the positions of test particles
fig, ax = plt.subplots()
ax.set_aspect("equal")
ax.plot(*zip(*test_particles_A), ".", label="Galaxy A")
ax.plot(*zip(*test_particles_B), ".", label="Galaxy B")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.legend()
plt.show()





////////////////////////////////////////////////////////////////////////////////////////////////////////////////









import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Set up initial conditions
G = 6.67430e-11  # Gravitational constant
m_A = 1e11  # Mass of galaxy A
m_B = 1e11  # Mass of galaxy B
R_min = 25  # Pericenter distance
e = 0.6  # Eccentricity
t_init = -16.4  # Initial time
t_final = 6.086  # Final time
dt = 0.01  # Time step

# Function to calculate gravitational force
def gravitational_force(m1, m2, r):
    return G * m1 * m2 / (r**2)

# Function to calculate acceleration
def acceleration(m1, m2, r, pos):
    force = gravitational_force(m1, m2, r)
    return force * pos / (m1 * r)

# Function to update positions and velocities using Leapfrog integration
def leapfrog_integration(pos, vel, acc, dt):
    pos += vel * dt + 0.5 * acc * dt**2
    vel += 0.5 * acc * dt
    return pos, vel

# Function to simulate the galaxy collision
def simulate_collision():
    t = t_init
    pos_A = np.array([0.7 * R_min, 0])  # Initial position of galaxy A
    vel_A = np.array([0, np.sqrt((1+e) * G * m_B / (0.7 * R_min))])  # Initial velocity of galaxy A
    pos_B = np.array([-0.7 * R_min, 0])  # Initial position of galaxy B
    vel_B = np.array([0, -np.sqrt((1+e) * G * m_A / (0.7 * R_min))])  # Initial velocity of galaxy B

    # Lists to store the positions of test particles
    test_particles_A = []
    test_particles_B = []

    while t <= t_final:
        # Update positions and velocities of galaxies
        r_A = np.linalg.norm(pos_A)
        r_B = np.linalg.norm(pos_B)
        acc_A = acceleration(m_A, m_B, r_A, pos_A)
        acc_B = acceleration(m_B, m_A, r_B, pos_B)
        pos_A, vel_A = leapfrog_integration(pos_A, vel_A, acc_A, dt)
        pos_B, vel_B = leapfrog_integration(pos_B, vel_B, acc_B, dt)

        # Append positions of test particles to the lists
        test_particles_A.append(pos_A.copy())
        test_particles_B.append(pos_B.copy())

        t += dt

    return test_particles_A, test_particles_B

# Run the simulation
test_particles_A, test_particles_B = simulate_collision()

# Set up the figure and axes
fig, ax = plt.subplots()
ax.set_aspect("equal")
scatter_A = ax.scatter([], [], color="blue", label="Galaxy A")
scatter_B = ax.scatter([], [], color="red", label="Galaxy B")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.legend()

# Function to update the plot for each frame of the animation
def update_plot(frame):
    scatter_A.set_offsets(test_particles_A[frame])
    scatter_B.set_offsets(test_particles_B[frame])

# Create the animation
animation_frames = len(test_particles_A)
ani = animation.FuncAnimation(fig, update_plot, frames=animation_frames,
                              interval=50, blit=False)

# Display the animation
plt.show()
